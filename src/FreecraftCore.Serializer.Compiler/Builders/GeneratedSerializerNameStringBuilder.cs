using System;
using System.Collections.Generic;
using System.Text;
using JetBrains.Annotations;

namespace FreecraftCore.Serializer
{
	public interface INameBuildable
	{
		string BuildName();
	}

	internal sealed class GeneratedSerializerNameStringBuilder
	{
		public static INameBuildable Create([NotNull] Type serializableType)
		{
			if (serializableType == null) throw new ArgumentNullException(nameof(serializableType));

			return (INameBuildable) Activator.CreateInstance(typeof(GeneratedSerializerNameStringBuilder<>).MakeGenericType(serializableType));
		}
	}

	internal sealed class GeneratedSerializerNameStringBuilder<TSerializableType> : INameBuildable
		where TSerializableType : new()
	{
		public const string SERIALIZER_NAME = nameof(AutoGeneratedTemplateSerializerStrategy);

		public override string ToString()
		{
			return $"{ComputeName(typeof(TSerializableType))}_{SERIALIZER_NAME}";
		}

		public string BuildName()
		{
			return ToString();
		}

		private static string ComputeName(Type type)
		{
			if (type.IsGenericType)
			{
				string baseName = type.Name.Remove(type.Name.IndexOf('`'));
				StringBuilder builder = new StringBuilder(baseName);
				builder.Append('_');

				//TODO: For long names this could exceed the name
				//The common language runtime imposes a limitation on the full class name length, specifying that it should not exceed 1,023 bytes in UTF-8 encoding.
				foreach (var genericTypeArg in type.GetGenericArguments())
				{
					if(genericTypeArg.IsGenericType && genericTypeArg != type) //Avoid self referencing generic types??
					{
						//There is a case when the generic type arg ITSELF may be generic
						//therefore we must recursively compute the type name
						builder.Append(ComputeName(genericTypeArg));
					}
					else
						builder.Append($"{genericTypeArg.Name}");
				}

				if (builder.Length > 1000)
					throw new InvalidOperationException($"Generated serializer name far too large. Requested: {builder.Length} Max: {1000} Name: {builder.ToString()}");

				return builder.ToString();

			}
			else
				return typeof(TSerializableType).Name;
		}
	}
}
